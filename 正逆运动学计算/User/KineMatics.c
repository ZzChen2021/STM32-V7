/*
*********************************************************************************************************
*
*	模块名称 : 运动学计算
*	文件名称 : KineMatics.c
*	版    本 : V1.0
*	说    明 : 计算正逆运动学
*
*	修改记录 :
*		版本号   日期         作者        说明
*		V1.0    2023-5-12     ZCH         1.模块创建
*
*********************************************************************************************************
*/

#include <bsp.h>
#include <arm_math.h>
#include <stdlib.h>
#include <math.h>

/*
*********************************************************************************************************
*	函 数 名: KM
*	功能说明: 正运动学计算
*	形    参：
*               float32_t q[6]：传入弧度值
*               float Tfk[5][5]：保存运动学公式计算出的角度值
*               unsigned char *p：用于标识是否计算出了Tfk
*	返 回 值: 无
*********************************************************************************************************
*/
void KM(float32_t q[6], float32_t Tfk[5][5], uint8_t *p)
{
    uint8_t i, j;
    float32_t c1, c2, c4, c5, s1, s2, s4, s5, c23, s23;
    float32_t t[5][5]; // 用于验证，避免验证时改变原Tfk数组中的值
    c1 = arm_cos_f32(q[1]);
    c2 = arm_cos_f32(q[2]);
    c4 = arm_cos_f32(q[4]);
    c5 = arm_cos_f32(q[5]);
    c23 = arm_cos_f32(q[2] + q[3]);
    s1 = arm_sin_f32(q[1]);
    s2 = arm_sin_f32(q[2]);
    s4 = arm_sin_f32(q[4]);
    s5 = arm_sin_f32(q[5]);
    s23 = arm_sin_f32(q[2] + q[3]);
    if ((*p) > 0) // 验证
    {
        /******************正运动学公式******************/
        t[1][1] = c5 * (s1 * s4 + c23 * c1 * c4) - s23 * c1 * s5;
        t[2][1] = -c5 * (c1 * s4 - c23 * c4 * s1) - s23 * s1 * s5;
        t[3][1] = -c23 * s5 - s23 * c4 * c5;
        t[4][1] = 0;
        t[1][2] = -s5 * (s1 * s4 + c23 * c1 * c4) - s23 * c1 * c5;
        t[2][2] = s5 * (c1 * s4 - c23 * c4 * s1) - s23 * c5 * s1;
        t[3][2] = s23 * c4 * s5 - c23 * c5;
        t[4][2] = 0;
        t[1][3] = c23 * c1 * s4 - c4 * s1;
        t[2][3] = c1 * c4 + c23 * s1 * s4;
        t[3][3] = -s23 * s4;
        t[4][3] = 0;
        t[1][4] = 25 * c1 * (11 * s23 + 10 * c2);
        t[2][4] = 25 * s1 * (11 * s23 + 10 * c2);
        t[3][4] = 275 * c23 - 250 * s2;
        t[4][4] = 1;
        /******************正运动学公式******************/
    }
    else // 求解
    {
        Tfk[1][1] = c5 * (s1 * s4 + c23 * c1 * c4) - s23 * c1 * s5;
        Tfk[2][1] = -c5 * (c1 * s4 - c23 * c4 * s1) - s23 * s1 * s5;
        Tfk[3][1] = -c23 * s5 - s23 * c4 * c5;
        Tfk[4][1] = 0;
        Tfk[1][2] = -s5 * (s1 * s4 + c23 * c1 * c4) - s23 * c1 * c5;
        Tfk[2][2] = s5 * (c1 * s4 - c23 * c4 * s1) - s23 * c5 * s1;
        Tfk[3][2] = s23 * c4 * s5 - c23 * c5;
        Tfk[4][2] = 0;
        Tfk[1][3] = c23 * c1 * s4 - c4 * s1;
        Tfk[2][3] = c1 * c4 + c23 * s1 * s4;
        Tfk[3][3] = -s23 * s4;
        Tfk[4][3] = 0;
        Tfk[1][4] = 25 * c1 * (11 * s23 + 10 * c2);
        Tfk[2][4] = 25 * s1 * (11 * s23 + 10 * c2);
        Tfk[3][4] = 275 * c23 - 250 * s2;
        Tfk[4][4] = 1;
    }
    for (i = 1; i < 5; i++)
    {
        for (j = 1; j < 5; j++)
        {
            if ((*p) > 0)
            {
                printf("%11.6f ", t[i][j]);
            }
            else
            {
                printf("%11.6f ", Tfk[i][j]);
            }
        }
        printf("\r\n");
    }
    *p = 1;
}

/*
*********************************************************************************************************
*	函 数 名: con_KM
*	功能说明: 逆运动学计算
*	形    参：
*               float Tfk[5][5]：保存运动学公式计算出的角度值
*               unsigned char *p：用于标识是否计算出了Tfk
*	返 回 值: 无
*********************************************************************************************************
*/
void con_KM(float32_t Tfk[5][5], uint8_t *p)
{
    uint8_t flag;
    float32_t Q[6], Q23, Sqart, cq1, sq1, sq4, cq23, sq23;
    float32_t qx, qy; // 用于判断逆运动学结果正确性
    flag = *p;        // 用于标识是否完成了正向计算
    uint8_t i, j;

    if (flag == 1)
    {
        for (; flag < 5; flag++) // 计算逆运动学的四种结果
        {
            /******************逆运动学公式******************/
            if ((flag == 1) || (flag == 3))
            {
                Q[1] = atan2(0, -1) - atan2(Tfk[2][4], -Tfk[1][4]);
            }
            else
            {
                Q[1] = atan2(0, 1) - atan2(Tfk[2][4], -Tfk[1][4]);
            }
            cq1 = arm_cos_f32(Q[1]);
            sq1 = arm_sin_f32(Q[1]);
            arm_sqrt_f32((Tfk[2][1] * cq1 - Tfk[1][1] * sq1) * (Tfk[2][1] * cq1 - Tfk[1][1] * sq1) + (Tfk[2][2] * cq1 - Tfk[1][2] * sq1) * (Tfk[2][2] * cq1 - Tfk[1][2] * sq1), &Sqart);
            if ((flag == 1) || (flag == 4))
            {
                Q[4] = atan2(Sqart, Tfk[2][3] * cq1 - Tfk[1][3] * sq1);
            }
            else
            {
                Q[4] = atan2(-Sqart, Tfk[2][3] * cq1 - Tfk[1][3] * sq1);
            }
            sq4 = arm_sin_f32(Q[4]);
            Q[5] = atan2((Tfk[2][2] * cq1 - Tfk[1][2] * sq1) / sq4, (Tfk[1][1] * sq1 - Tfk[2][1] * cq1) / sq4);
            Q23 = atan2((-Tfk[3][3]) / sq4, (Tfk[1][3] * cq1 + Tfk[2][3] * sq1) / sq4);
            cq23 = arm_cos_f32(Q23);
            sq23 = arm_sin_f32(Q23);
            qx = ((275 * cq23) - Tfk[3][4]) / 250;
            qy = (Tfk[1][4] * cq1 + Tfk[2][4] * sq1 - 275 * sq23) / 250;
            Q[2] = atan2(((275 * cq23) - Tfk[3][4]) / 250, (Tfk[1][4] * cq1 + Tfk[2][4] * sq1 - 275 * sq23) / 250);
            Q[3] = Q23 - Q[2];
            /******************逆运动学公式******************/

            if ((qx > 1) || (qx < (-1)) || (qy > 1) || (qy < (-1)))
            {
                printf("第%d组解错误！\r\n", flag);
            }
            else
            {
                printf("第%d组解:\n%11.6f %11.6f %11.6f %11.6f %11.6f\r\n", flag, Q[1], Q[2], Q[3], Q[4], Q[5]);
                printf("验证第%d组解:\r\n", flag);
                KM(Q, Tfk, p);
            }
        }
    }
}